<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>/비트/외래 통계 자동 계산 도구 · 개선판 v3</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- xlsx: Excel/CSV 파서 -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <style>
    :root {
      --bg: #ffffff;
      --text: #1f2937;
      --muted: #6b7280;
      --ring: #2563eb33;
      --card: #f8fafc;
      --border: #e5e7eb;
    }
    * { box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple SD Gothic Neo", "Noto Sans KR", sans-serif; margin: 0; background: var(--bg); color: var(--text); }
    header { position: sticky; top: 0; z-index: 5; background: rgba(255,255,255,0.9); backdrop-filter: saturate(150%) blur(6px); border-bottom: 1px solid var(--border); }
    .wrap { max-width: 1120px; margin: 0 auto; padding: 20px; }
    h1 { margin: 0; font-size: 20px; font-weight: 700; letter-spacing: -0.2px; }

    .controls { display: grid; grid-template-columns: 1fr; gap: 12px; margin-top: 14px; }
    .row { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
    label { font-size: 13px; color: var(--muted); }
    input[type="text"] { padding: 10px 12px; border: 1px solid var(--border); border-radius: 10px; min-width: 240px; }
    input[type="file"] { padding: 8px; }
    button { appearance: none; border: 1px solid var(--border); background: var(--card); padding: 10px 14px; border-radius: 10px; cursor: pointer; font-weight: 600; }
    button.primary { background: #2563eb; color: #fff; border-color: #1d4ed8; }
    button:disabled { opacity: .5; cursor: not-allowed; }

    .dropzone { border: 2px dashed #cbd5e1; border-radius: 14px; padding: 18px; display: grid; gap: 8px; background: #f8fafc; }
    .dropzone.drag { outline: 4px solid var(--ring); background: #eff6ff; }
    .hint { font-size: 12px; color: var(--muted); }

    .cards { display: grid; gap: 12px; margin-top: 18px; }
    .card { background: var(--card); border: 1px solid var(--border); border-radius: 14px; padding: 14px; }
    .warn { color: #dc2626; font-weight: 700; }
    .ok { color: #059669; font-weight: 700; }

    .table-wrap { margin-top: 16px; border: 1px solid var(--border); border-radius: 12px; overflow: clip; }
    table { border-collapse: separate; border-spacing: 0; width: 100%; font-size: 13px; }
    thead th { position: sticky; top: 0; background: #f1f5f9; z-index: 2; }
    th, td { border-bottom: 1px solid var(--border); padding: 8px 10px; text-align: center; }
    tbody tr.whole { background-color: #eaf2f8; }
    tbody tr.room1 { background-color: #fef9e7; }
    tbody tr.room2 { background-color: #e8f8f5; }
    tbody tr.room3 { background-color: #fbeee6; }
    tbody tr.room4 { background-color: #f9ebea; }
    tbody tr.room5 { background-color: #f5eef8; }

    .grid2 { display: grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap: 10px; }
    @media (max-width: 720px) { .grid2 { grid-template-columns: 1fr; } }

    .kvs { display: flex; flex-wrap: wrap; gap: 10px; font-size: 12px; color: var(--muted); }
    .kvs span { background: #f1f5f9; border: 1px solid var(--border); border-radius: 999px; padding: 4px 8px; }

    .spinner { width: 16px; height: 16px; border: 2px solid #cbd5e1; border-top-color: #2563eb; border-radius: 50%; display: inline-block; animation: spin .7s linear infinite; vertical-align: text-bottom; }
    @keyframes spin { to { transform: rotate(360deg); } }

    .options { display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
    .options label { display:flex; gap:6px; align-items:center; }
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <h1>/비트/외래 통계 자동 계산기 · 개선판 v3</h1>
      <div class="controls">
        <div class="row">
          <label>✔️ 특정 키워드(예: PT만):</label>
          <input type="text" id="keywordInput" placeholder="예: PT만" />
          <div class="options">
            <label><input type="checkbox" id="keywordFilter" /> 키워드 일치 행만 분석</label>
            <label><input type="text" id="injMark" placeholder="주사 마킹 문자 (기본 ●)" style="min-width:180px;" /></label>
          </div>
          <button id="clearBtn" title="초기화">초기화</button>
          <button id="exportBtn" class="primary" disabled>엑셀로 내보내기</button>
        </div>
        <div id="dropzone" class="dropzone" aria-label="파일 드롭 영역">
          <strong>엑셀(.xlsx) 또는 CSV 파일을 선택하거나 여기에 끌어다 놓으세요</strong>
          <div class="row">
            <input type="file" id="fileInput" accept=".xlsx,.csv" />
          </div>
          <div class="hint">헤더 자동 인식(초/재, 차트/챠트/ID, 진료과/과목, 마취, 메모, 나이/연령/생년/S/A) · 큰 파일은 첫번째 시트부터 순차 병합</div>
        </div>
      </div>
    </div>
  </header>

  <main class="wrap">
    <section class="cards">
      <div id="status" class="card">
        <div id="statusText" class="hint">파일을 불러오면 여기 상태가 표시됩니다.</div>
      </div>
      <div class="card">
        <div class="kvs" id="colMap"></div>
        <div id="manualMap"></div>
        <div id="warning" class="warn" role="alert"></div>
        <div id="output" class="table-wrap" aria-live="polite"></div>
      </div>
    </section>
  </main>

  <script>
    // ====== 상태 ======
    let lastRows = null;   // 계산 원본(df)
    let lastResult = null; // 집계 결과 테이블
    let currentColMap = null; // 매핑 보존

    // ====== 상수 & 유틸 ======
    const AGE_ORDER = ["0~10대", "20대", "30대", "40대", "50대~64세", "65세이상", "전체"];
    const fmtInt = (n) => (isFinite(n) ? new Intl.NumberFormat().format(n|0) : "0");
    const asPct = (n, d) => (d > 0 ? Math.round((n/d)*100) : 0) + "%";

    function getAgeGroup(raw) {
      if (raw == null) return "전체";
      const s = String(raw);
      const m = s.match(/(\d{1,3})\s*세/);
      const age = m ? parseInt(m[1], 10) : (isFinite(+s) ? +s : NaN);
      if (!Number.isFinite(age)) return "전체";
      if (age <= 19) return "0~10대";
      if (age <= 29) return "20대";
      if (age <= 39) return "30대";
      if (age <= 49) return "40대";
      if (age <= 64) return "50대~64세";
      return "65세이상";
    }

    function sortResult(a, b) {
      if (a["구분"] !== b["구분"]) return a["구분"].localeCompare(b["구분"]);
      return AGE_ORDER.indexOf(a["연령대"]) - AGE_ORDER.indexOf(b["연령대"]);
    }

    function status(msg, ok=false) {
      const el = document.getElementById('statusText');
      el.innerHTML = (ok ? '<span class="ok">✔</span> ' : '<span class="spinner"></span> ') + msg;
    }

    // ====== 테이블 렌더링 ======
    function renderTable(result) {
      if (!result || !result.length) {
        document.getElementById('warning').innerText = '❗ 통계 데이터를 생성할 수 없습니다. 열 이름을 확인하세요.';
        document.getElementById('exportBtn').disabled = true;
        document.getElementById('output').innerHTML = '';
        return;
      }
      result.sort(sortResult);
      const keys = Object.keys(result[0] || {}).filter(k => k !== '구분' && k !== '연령대');

      let html = '<table><thead><tr><th>구분</th><th>연령대</th>' + keys.map(k => `<th>${k}</th>`).join('') + '</tr></thead><tbody>';
      let prevGroup = null;
      let groupRows = {};
      result.forEach(row => { groupRows[row["구분"]] = (groupRows[row["구분"]] || 0) + 1; });

      result.forEach(row => {
        const className = row["구분"].includes("전체") ? "whole" :
                          row["구분"].includes("1진료실") ? "room1" :
                          row["구분"].includes("2진료실") ? "room2" :
                          row["구분"].includes("3진료실") ? "room3" :
                          row["구분"].includes("4진료실") ? "room4" :
                          row["구분"].includes("5진료실") ? "room5" : "";

        html += `<tr class="${className}">`;
        if (row["구분"] !== prevGroup) {
          html += `<td rowspan="${groupRows[row["구분"]]}">${row["구분"]}</td>`;
          prevGroup = row["구분"];
        }
        html += `<td>${row["연령대"]}</td>` + keys.map(k => `<td>${row[k]}</td>`).join('') + '</tr>';
      });

      html += '</tbody></table>';
      const out = document.getElementById('output');
      out.innerHTML = html;
      document.getElementById('exportBtn').disabled = false;
    }

    // ====== 파일 읽기 ======
    const fileInput = document.getElementById('fileInput');
    const drop = document.getElementById('dropzone');
    const keyInput = document.getElementById('keywordInput');
    const keywordFilter = document.getElementById('keywordFilter');
    const injMarkInput = document.getElementById('injMark');

    // 기본값 유지
    keyInput.value = localStorage.getItem('keywordInput') || '';
    injMarkInput.value = localStorage.getItem('injMark') || '●';
    keywordFilter.checked = localStorage.getItem('keywordFilter') === '1';

    keyInput.addEventListener('input', () => localStorage.setItem('keywordInput', keyInput.value));
    injMarkInput.addEventListener('input', () => localStorage.setItem('injMark', injMarkInput.value || '●'));
    keywordFilter.addEventListener('change', () => localStorage.setItem('keywordFilter', keywordFilter.checked ? '1' : '0'));

    function handleFiles(files) {
      const file = files?.[0];
      if (!file) return;

      // 업로드 시 자동으로 키워드 필터 초기화 → 전체 데이터 기준 계산 보장
      keyInput.value = '';
      keywordFilter.checked = false;
      localStorage.removeItem('keywordInput');
      localStorage.removeItem('keywordFilter');

      status(`파일 분석 중: ${file.name}`);
      const reader = new FileReader();
      reader.onload = (evt) => {
        try {
          const data = new Uint8Array(evt.target.result);
          const wb = XLSX.read(data, { type: 'array' });
          let raw = [];
          wb.SheetNames.forEach(sheet => {
            const rows = XLSX.utils.sheet_to_json(wb.Sheets[sheet], { header: 1, defval: "" });
            raw = raw.concat(rows);
          });
          parseData(raw, (keyInput.value||'').trim().toLowerCase());
        } catch (e) {
          console.error(e);
          document.getElementById('warning').textContent = '❗ 파일 처리 중 오류가 발생했습니다. 파일 형식 또는 인코딩 문제일 수 있습니다. 엑셀에서 "다른 이름으로 저장" → XLSX 또는 CSV UTF-8로 저장 후 다시 시도하세요. 상세: ' + (e.message||e);
          status('오류가 발생했습니다.', true);
        }
      };
      reader.readAsArrayBuffer(file);
    }

    fileInput.addEventListener('change', (e) => handleFiles(e.target.files));

    ;['dragenter','dragover'].forEach(ev => drop.addEventListener(ev, e => { e.preventDefault(); drop.classList.add('drag'); }));
    ;['dragleave','drop'].forEach(ev => drop.addEventListener(ev, e => { e.preventDefault(); drop.classList.remove('drag'); }));
    drop.addEventListener('drop', (e) => handleFiles(e.dataTransfer.files));

    // ====== 파서 & 통계 ======
    function parseData(data, keyword) {
      const warning = document.getElementById('warning');
      warning.textContent = '';
      document.getElementById('colMap').innerHTML = '';
      const manual = document.getElementById('manualMap');
      manual.innerHTML = '';

      // 1) 헤더 탐색 (유연화)
      const hasText = (v) => (v ?? '').toString().trim() !== '';
      let headerIdx = data.findIndex(row => row.some(hasText) && (
        row.join(' ').includes('초/재') || row.join(' ').includes('챠트') || row.join(' ').includes('차트') || row.join(' ').includes('진료과') || row.join(' ').toLowerCase().includes('id')
      ));
      if (headerIdx === -1) headerIdx = data.findIndex(row => row.filter(hasText).length >= 2);
      if (headerIdx === -1) { warning.textContent = '❗ 유효한 헤더를 찾을 수 없습니다. (파일 첫 행들이 모두 빈 값)'; status('헤더를 찾지 못했습니다.', true); return; }

      // 2) 헤더/바디 정제
      let headers = data[headerIdx].map(h => (h ?? '').toString().replace(/^﻿/, '').trim()); // BOM 제거
      headers = headers.map((h, i) => h || `COL_${i+1}`);
      const body = data.slice(headerIdx + 1).filter(r => (r?.some?.(hasText)));
      if (!body.length) { warning.textContent = '❗ 데이터 행이 없습니다. 헤더 아래에 내용이 있는지 확인하세요.'; status('데이터 없음', true); return; }

      const df = body.map(row => Object.fromEntries(headers.map((h,i) => [h, (row[i] ?? '').toString().trim()])));
      status(`헤더 인식: ${headers.length}개 컬럼 · 데이터: ${df.length}행`, true);

      // 3) 컬럼 매핑(느슨한 한글/영문 키워드)
      let col = {};
      headers.forEach(h => {
        const l = h.toLowerCase();
        if (!col['초재'] && ((l.includes('초') && l.includes('재')) || l.includes('new/return'))) col['초재'] = h;
        if (!col['차트'] && (l.includes('차트') || l.includes('챠트') || l.includes('id'))) col['차트'] = h;
        if (!col['과'] && ((l.includes('진료') && l.includes('과')) || l.includes('과목') || l.includes('dept'))) col['과'] = h;
        if (!col['마취'] && (l.includes('마취') || l.includes('injection') || l.includes('block'))) col['마취'] = h;
        if (!col['메모'] && (l.includes('메모') || l.includes('note') || l.includes('remark'))) col['메모'] = h;
        if (!col['연령'] && (l.includes('나이') || l.includes('연령') || l.includes('생년') || l.includes('s/a') || l.includes('age'))) col['연령'] = h;
      });

      // 4) 매핑 표시
      const mapEl = document.getElementById('colMap');
      const kvs = [
        ['초/재 구분','초재'], ['차트/ID','차트'], ['진료과','과'], ['마취/주사','마취'], ['메모','메모'], ['연령(선택)','연령']
      ].map(([label,key]) => `<span>${label}: <b>${col[key]||'미설정'}</b></span>`).join('');
      mapEl.innerHTML = kvs;

      // 5) 필수 누락 시 수동 매핑 UI 제공 + 저장/복원
      const needManual = !col['초재'] || !col['차트'];
      const select = (id, label) => {
        return `<label style="display:block;margin:6px 0 4px;">${label}</label>
                <select id="${id}" style="padding:8px;border:1px solid #e5e7eb;border-radius:8px;min-width:240px;">`
                + headers.map(h=>`<option value="${h}">${h}</option>`).join('')
                + `</select>`;
      };

      function saveColToLocal(col){ localStorage.setItem('colMap', JSON.stringify(col)); }
      function loadColFromLocal(){ try { return JSON.parse(localStorage.getItem('colMap')||'null'); } catch { return null; } }

      const saved = loadColFromLocal();
      if (saved) {
        ['초재','차트','과','마취','메모','연령'].forEach(k=>{ if (saved[k] && headers.includes(saved[k])) col[k]=saved[k]; });
      }

      if (needManual) {
        warning.innerHTML = '❗ 필수 열(초/재, 차트/ID)을 자동으로 찾지 못했습니다. 아래에서 직접 선택 후 “재계산”을 눌러주세요.';
        document.getElementById('manualMap').innerHTML = `
          <div class=\"card\" style=\"margin-top:10px;\">
            ${select('m_chore','초/재 열 선택')}
            ${select('m_chart','차트/ID 열 선택')}
            <details style=\"margin-top:8px;\">
              <summary>선택(옵션) 열</summary>
              ${select('m_dept','진료과 열 선택(선택)')}
              ${select('m_anes','마취/주사 열 선택(선택)')}
              ${select('m_memo','메모 열 선택(선택)')}
              ${select('m_age','연령/나이 열 선택(선택)')}
            </details>
            <div style=\"margin-top:10px;display:flex;gap:8px;\">
              <button id=\"recalcBtn\" class=\"primary\">재계산</button>
              <button id=\"saveMapBtn\">매핑 저장</button>
              <button id=\"clearMapBtn\">매핑 초기화</button>
            </div>
          </div>`;
        document.getElementById('recalcBtn').onclick = () => {
          col['초재'] = document.getElementById('m_chore').value;
          col['차트'] = document.getElementById('m_chart').value;
          col['과'] = document.getElementById('m_dept').value || col['과'];
          col['마취'] = document.getElementById('m_anes').value || col['마취'];
          col['메모'] = document.getElementById('m_memo').value || col['메모'];
          col['연령'] = document.getElementById('m_age').value || col['연령'];
          saveColToLocal(col);
          document.getElementById('manualMap').innerHTML = '';
          computeAndRender();
        };
        document.getElementById('saveMapBtn').onclick = () => { saveColToLocal({
          '초재':document.getElementById('m_chore').value,
          '차트':document.getElementById('m_chart').value,
          '과':document.getElementById('m_dept').value,
          '마취':document.getElementById('m_anes').value,
          '메모':document.getElementById('m_memo').value,
          '연령':document.getElementById('m_age').value,
        }); alert('매핑 저장 완료'); };
        document.getElementById('clearMapBtn').onclick = () => { localStorage.removeItem('colMap'); alert('매핑 삭제 완료'); };
      } else {
        saveColToLocal(col);
        computeAndRender();
      }

      // 6) 계산 및 렌더 함수
      function computeAndRender(){
        currentColMap = col;
        let df0 = df;
        // 키워드 필터(옵션)
        const memoKey = (col['메모']||'');
        if (keywordFilter.checked && memoKey && (keyword||'').length > 0) {
          df0 = df0.filter(r => (r[memoKey]||'').toLowerCase().includes(keyword));
        }

        lastRows = df0;
        const result = [];
        const 재진조건 = ["재진", "물리치료내원", "진찰료 산정안함"]; // 필요 시 수정

        const makeStat = (rows, label, ageGroup = "전체") => {
          const injAvailable = !!col['마취'];
          const 초진조건표 = ["신환","90일초진","초진","초진(신환)","초진환자"];
          const 초진Rows = rows.filter(r => {
            const v = String(r[col['초재']]||'');
            return 초진조건표.some(s => v.includes(s));
          });
          const 초진차트 = [...new Set(초진Rows.map(r => r[col['차트']]).filter(Boolean))];
          const 재진Rows = rows.filter(r => 재진조건.includes(r[col['초재']]));
          const 재진차트 = [...new Set(재진Rows.map(r => r[col['차트']]).filter(Boolean))];
          const 총 = rows.length;

          // 주사 표시는 마취 칼럼 내 마킹 문자 포함(초진 기준) — 자동 탐지 + 수동 입력 병행
          let INJ_MARK = (injMarkInput.value || '●');
          if (injAvailable) {
            const detectInjMark = (rows, colName) => {
              const freq = {};
              rows.forEach(r => {
                const raw = (r[colName] || '').trim();
                if (!raw) return;
                const norm = raw.replace(/\s+/g,'').replace(/○/g,'O');
                const ch = norm[0];
                freq[ch] = (freq[ch]||0)+1;
              });
              const top = Object.entries(freq).sort((a,b)=>b[1]-a[1])[0];
              return top ? top[0] : '●';
            };
            if (!injMarkInput.value) {
              INJ_MARK = detectInjMark(df0, col['마취']);
              injMarkInput.value = INJ_MARK;
              localStorage.setItem('injMark', INJ_MARK);
            }
          }

          const 주사Rows = injAvailable ? (
            초진Rows.filter(r => (r[col['마취']]||'').includes(INJ_MARK))
          ) : [];
          const 주사차트 = [...new Set(주사Rows.map(r => r[col['차트']]).filter(Boolean))];
          const 주사기록 = rows.filter(r => 주사차트.includes(r[col['차트']]));

          // 환자별 횟수 집계
          const countBy = (rows, key, cond = () => true) => rows.reduce((acc, r) => { const id = r[key]; if (!id) return acc; if (!acc[id]) acc[id] = 0; if (cond(r)) acc[id]++; return acc; }, {});
          const 주사횟수 = injAvailable ? countBy(주사기록, col['차트'], r => (r[col['마취']]||'').includes(INJ_MARK)) : {};
          const 내원횟수 = countBy(주사기록, col['차트'], () => true);

          const mean = (obj) => { const ks = Object.keys(obj); if (!ks.length) return 0; return (ks.reduce((s,k)=>s+obj[k],0)/ks.length); };
          const 평균주사 = injAvailable ? mean(주사횟수).toFixed(1) : '-';
          const 평균내원 = injAvailable ? mean(내원횟수).toFixed(1) : '-';

          // 주사 횟수 분포(초진환자 중 주사경험자 기준)
          let injPct = (n) => '-';
          let inj8Plus = '-';
          if (injAvailable) {
            const injCountById = {};
            rows.forEach(r => {
              const id = r[col['차트']]; if (!id) return;
              if (!초진차트.includes(id)) return; // 초진환자만 카운트
              if (!injCountById[id]) injCountById[id] = 0;
              if ((r[col['마취']]||'').includes(INJ_MARK)) injCountById[id]++;
            });
            const injCounts = 초진차트.map(id => injCountById[id] || 0);
            const injCountsNZ = injCounts.filter(v => v >= 1);
            const injDen = injCountsNZ.length || 0; // 母수: 주사치료 경험(>=1회) 있는 초진환자 수
            injPct = (n) => asPct(injCountsNZ.filter(v => v === n).length, injDen);
            inj8Plus = asPct(injCountsNZ.filter(v => v >= 8).length, injDen);
          }

          const 키워드수 = (col['메모'] && keyword)
            ? rows.filter(r => (r[col['메모']] || '').toLowerCase().includes(keyword)).length
            : "";

          result.push({
            "구분": label,
            "연령대": ageGroup,
            "초진환자수": fmtInt(초진차트.length),
            "재진환자수(행)": fmtInt(재진Rows.length),
            "재진환자수(차트)": fmtInt(재진차트.length),
            "총행수": fmtInt(총),
            "초진 주사 처방률": injAvailable ? asPct(주사Rows.length, 초진차트.length || 0) : "-",
            "초진주사 갯수": injAvailable ? fmtInt(주사Rows.length) : "-",
            "초진 주사환자 재진율": injAvailable ? asPct(Object.values(내원횟수).filter(v => v >= 2).length, Object.keys(내원횟수).length || 0) : "-",
            "초진주사환자 평균 주사횟수": injAvailable ? 평균주사 : "-",
            "1회": injAvailable ? injPct(1) : "-",
            "2회": injAvailable ? injPct(2) : "-",
            "3회": injAvailable ? injPct(3) : "-",
            "4회": injAvailable ? injPct(4) : "-",
            "5회": injAvailable ? injPct(5) : "-",
            "6회": injAvailable ? injPct(6) : "-",
            "7회": injAvailable ? injPct(7) : "-",
            "8회이상": injAvailable ? inj8Plus : "-",
            "초진 주사환자 평균내원횟수": injAvailable ? 평균내원 : "-",
            "초진평균내원횟수": 초진평균내원횟수(rows, col, 초진차트).toFixed(1),
            "초진 재내원율": 재내원율(rows, col, 초진차트),
            "1회 내원 비율": 내원분포(rows, col, 초진차트, 1),
            "2회 내원 비율": 내원분포(rows, col, 초진차트, 2),
            "3회 내원 비율": 내원분포(rows, col, 초진차트, 3),
            "4회 내원 비율": 내원분포(rows, col, 초진차트, 4),
            "5회 이상 내원 비율": 내원5이상(rows, col, 초진차트),
            "특정 키워드 포함 메모 수": 키워드수
          });
        };

        function 초진평균내원횟수(rows, col, 초진차트){
          const 초진기록 = rows.filter(r => 초진차트.includes(r[col['차트']]));
          const 내원횟수 = 초진기록.reduce((acc,r)=>{const id=r[col['차트']]; if(!id) return acc; acc[id]=(acc[id]||0)+1; return acc;},{});
          const ks = Object.keys(내원횟수); if(!ks.length) return 0;
          return ks.reduce((s,k)=>s+내원횟수[k],0)/ks.length;
        }
        function 재내원율(rows, col, 초진차트){
          const 초진기록 = rows.filter(r => 초진차트.includes(r[col['차트']]));
          const 내원횟수 = 초진기록.reduce((acc,r)=>{const id=r[col['차트']]; if(!id) return acc; acc[id]=(acc[id]||0)+1; return acc;},{});
          const 재내원명수 = Object.values(내원횟수).filter(v => v >= 2).length;
          return asPct(재내원명수, 초진차트.length || 0);
        }
        function 내원분포(rows, col, 초진차트, n){
          const 초진기록 = rows.filter(r => 초진차트.includes(r[col['차트']]));
          const 내원횟수 = 초진기록.reduce((acc,r)=>{const id=r[col['차트']]; if(!id) return acc; acc[id]=(acc[id]||0)+1; return acc;},{});
          const cnt = Object.values(내원횟수).filter(v => v === n).length;
          return asPct(cnt, Object.keys(내원횟수).length || 0);
        }
        function 내원5이상(rows, col, 초진차트){
          const 초진기록 = rows.filter(r => 초진차트.includes(r[col['차트']]));
          const 내원횟수 = 초진기록.reduce((acc,r)=>{const id=r[col['차트']]; if(!id) return acc; acc[id]=(acc[id]||0)+1; return acc;},{});
          const cnt = Object.values(내원횟수).filter(v => v >= 5).length;
          return asPct(cnt, Object.keys(내원횟수).length || 0);
        }

        // 전체
        const 연령열존재 = !!col['연령'];
        const 전체 = df0;
        if (연령열존재) {
          AGE_ORDER.slice(0, -1).forEach(a => makeStat(전체.filter(r => getAgeGroup(r[col['연령']]) === a), "전체", a));
        }
        makeStat(전체, "전체", "전체");

        // 진료과 별
        const 진료과들 = [...new Set(df0.map(r => r[col['과']] || "기타"))];
        진료과들.forEach(과 => {
          const rows = df0.filter(r => (r[col['과']] || "기타") === 과);
          if (연령열존재) {
            AGE_ORDER.slice(0, -1).forEach(a => makeStat(rows.filter(r => getAgeGroup(r[col['연령']]) === a), 과, a));
          }
          makeStat(rows, 과, "전체");
        });

        lastResult = result;
        renderTable(result);
        status(`완료: ${fmtInt(df0.length)}개 행 처리`, true);
        document.getElementById('exportBtn').disabled = false;
      }
    }

    // ====== 엑셀 내보내기 ======
    function exportResult(rows) {
      if (!rows || !rows.length) return;
      const ws = XLSX.utils.json_to_sheet(rows);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, '외래 통계');
      XLSX.writeFile(wb, `외래_통계_${new Date().toISOString().slice(0,10)}.xlsx`);
    }

    document.getElementById('exportBtn').addEventListener('click', () => {
      if (!lastResult || !lastResult.length) {
        alert('내보낼 결과가 없습니다. 파일을 불러와 먼저 분석하세요.');
        return;
      }
      exportResult(lastResult);
    });

    // ====== UX 보조 ======
    document.getElementById('clearBtn').addEventListener('click', () => {
      document.getElementById('output').innerHTML = '';
      document.getElementById('warning').textContent = '';
      document.getElementById('colMap').innerHTML = '';
      document.getElementById('exportBtn').disabled = true;
      fileInput.value = '';
      lastRows = null; lastResult = null; currentColMap = null;
      status('초기화 완료. 파일을 불러오세요.', true);
    });

    // 초기 상태 메시지
    status('파일을 선택하거나 드래그해 주세요.', true);
  </script>
</body>
</html>
